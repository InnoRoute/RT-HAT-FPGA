BS_file="https://raw.githubusercontent.com/InnoRoute/RT-HAT-FPGA/main/common/4bd9630e96299c2117bb46e0ecb78a4623d9e04d_uc1.bit"
BS_repo_hash="4bd9630e96299c2117bb46e0ecb78a4623d9e04d"
C_BASE_ADDR_FACTOR="256" # BASE ADDRESS factors (to shift the base address left)
C_BASE_ADDR_TN_COMMON_L="0x0004"
C_BASE_ADDR_TN_COMMON_LOWER="0x0004"
C_BASE_ADDR_TN_COMMON="0x0004"
C_SUB_ADDR_MDIO_INTERRUPTS="0x08"
C_SUB_ADDR_MDIO_INTERRUPT_MASK="0x0C"
C_MMI_ADDR_MAP_REVISION="17"	#         Address map version  also provided in COMMON_MMI
C_BASE_ADDR_COMMON_LOWER="0x0004"	#  RO  Has to be a multiple of 4!
C_BASE_ADDR_COMMON_UPPER="0x0007"	#  RO
C_ADDR_COMMON_TN_MAJOR_REV="0x400"    	#  RO
C_ADDR_COMMON_TN_MINOR_REV="0x404"    	#  RO
C_ADDR_COMMON_USER_REV="0x408"    	#  RO
C_ADDR_COMMON_ADDR_MAP_REV="0x40c"    	#  RO: address map revision, and if the processor has to send&receive NoC1
C_ADDR_COMMON_FEATURES_USER_DEF_OUTPRT="0x500"    	#  RO
C_ADDR_COMMON_FEATURES_ETH_SW="0x504"    	#  RO
C_ADDR_COMMON_FEATURES_FLOWCACHE="0x508"    	#  RW  Availability of flowcache as a whole and of individual units, set default target: processor or loopback
C_ADDR_COMMON_FEATURES_ACC_DP="0x50c"    	#  RO
C_BASE_ADDR_SPI_LOWER="0x0C00"	#
C_BASE_ADDR_SPI_UPPER="0x0FFF"	#
C_ADDR_SPI_BOARD_REV="0xc0000"    	#  RO  Board ID pins (lower 3 bits), currently unused efuse_usr pins (upper bits)
C_ADDR_SPI_FPGA_TEMP="0xc0100"    	#  RO  Sampled current temperature value (12 bits)
C_ADDR_SPI_FPGA_ID0="0xc0200"    	#  RO  Unique ID, lower part, from DNA_PORT and EFUSE_USR (32 bits)
C_ADDR_SPI_FPGA_ID1="0xc0300"    	#  RO  Unique ID, upper part, from DNA_PORT and EFUSE_USR (32 bits)
C_ADDR_SPI_BITGEN_TIME="0xc0400"    	#  RO  Bitstream generation time. Not available in simulation (32 bits)
C_ADDR_SPI_FPGA_REV="0xc0500"    	#  RO  FPGA revision numbers: Use Case, Address Map, Design ID (8+8+16=32bits)
C_ADDR_SPI_FEATURE_MAP="0xc0600"    	#  RO  Contained basic features (32 bits)
C_ADDR_SPI_DATABASE_ID="0xc0700"    	#  RO  GIT Hash used for building FPGA bitstream
C_ADDR_SPI_INT_PENDING="0xc0800"    	#  RO  Masked Interrupts (32 bits: lower 10 bits used)
C_ADDR_SPI_INT_STATUS="0xc0900"    	#  RW  Raw Interrupts (32 bits: lower 10 bits used)
C_ADDR_SPI_INT_SET_EN="0xc0a00"    	#  RW  Enable Interrupts, Read returns current enable mask (32 bits)
C_ADDR_SPI_INT_CLR_EN="0xc0b00"    	#  RW  Disable Interrupts, Read returns current enable mask (32 bits)
C_ADDR_SPI_FPGA_ALARM="0xc0c00"    	#  RO  Latched/COR: Alarms from XADC (lower 6 bits)
C_ADDR_SPI_CONFIG_CHECK="0xc0d00"    	#  RO  Latched/COR: Alarms from FRAME_ECCE2 primitive (lower 3 bits)
C_ADDR_SPI_LICENSE="0xc0e00"    	#  RO  Licensed Features (lower 8 bits)
C_ADDR_SPI_ACCESS_ERROR="0xc0f00"    	#  RO  Latched/COR: SPI/MMI access errors (lower 8 bits)
C_ADDR_SPI_FIFO_OVERFLOW="0xc1000"    	#  RO  Latched/COR: FIFO overflows (32 bits)
C_ADDR_SPI_FIFO_UNDERRUN="0xc1100"    	#  RO  Latched/COR: FIFO underrus (32 bits)
C_ADDR_SPI_EXT_INTERRUPT="0xc1200"    	#  RO  Latched/COR: Hardware interrupts: PMIC, PHYs, LINKST (7 bits)
C_ADDR_SPI_EVENT="0xc1300"    	#  RW  Latched/COR: Partial COR: WDT (24 bits, multiples of 64ns), Timer interrupt/PPS, Cycle Starts (total: 32 bits)
C_ADDR_SPI_MMI_INT_BITMAP="0xc1400"    	#  RO  Latched/COR: Interrupts from MMI units  NO MASKING ON THIS LEVEL
C_ADDR_SPI_BACKPRESSURE="0xc1500"    	#  RO  Latched/COR: TXFs, TREADYs, TMFull (2 bits, one per edge)
C_ADDR_SPI_RESET="0xc1600"    	#  RW: MMI + PHY Resets (active high)
C_ADDR_SPI_DRIVE_PPS="0xc1700"    	#  RW: Drive PPS signal (instead of just sampling it)
C_ADDR_SPI_TEST_DRIVE="0xc1800"    	#  WO (32 bits)
C_ADDR_SPI_TEST_VALUE="0xc1900"    	#  WO (32 bits)
C_ADDR_SPI_TEST_INPUT="0xc1a00"    	#  RO  gp_clklocking (3 bits), ... (32 bits)
C_ADDR_SPI_ID_ROM_LOWER="0xc2000"    	#  RO  Jenkinsgenerated ID values
C_ADDR_SPI_ID_ROM_UPPER="0xc2f00"    	#  RO  Jenkinsgenerated ID values
C_BASE_ADDR_ACC_0="0x1000"	#
C_BASE_ADDR_ACC_1="0x2800"	#
C_BASE_ADDR_NET_LOWER="0x4000"	#  eth_mac_common
C_BASE_ADDR_NET_UPPER="0x400F"	#  eth_mac_common > C_BASE_ADDR_NET_LOWER should be sufficient
C_ADDR_NET_TAP="0x400000"    	#  WO, lower 16 bits writeenable per port, lower part of the upper 16 bits as tap value
C_ADDR_NET_SPEED_DEBUG1="0x400004"    	#  RW: MAC Speed: 10/100/1000 Mbps, Values: 0=10M, 1=100M, 2=1G, 2 bits per port
C_ADDR_NET_SPEED_DEBUG2="0x400008"    	#  RW: MAC Speed: 10/100/1000 Mbps, Values: 0=10M, 1=100M, 2=1G, 2 bits per port
C_ADDR_NET_ENABLE="0x400010"    	#  RW: RX MAC Enable (by default disabled), one bit per port
C_ADDR_NET_SPEED="0x400014"    	#  RW: MAC Speed: 10/100/1000 Mbps, Values: 0=10M, 1=100M, 2=1G, 2 bits per port
C_ADDR_NET_DUPLEX="0x400018"    	#  RW: MAC Duplex: 0=Full Duplex, 1=Half Duplex, one bit per port @todo To be implemented
C_ADDR_NET_PAUSE="0x40001c"    	#  RW: RX MAC PAUSE Enable, one bit per port
C_ADDR_NET_LINK="0x400020"    	#  WO: PHY signals link up
C_ADDR_NET_OWN_MAC_ADDR_L="0x400024"    	#  WO: lower 32Bit of our own MAC Address
C_ADDR_NET_OWN_MAC_ADDR_H="0x400028"    	#  WO: upper Bits of our own MAC Address
C_ADDR_NET_PORT_ISOLATION="0x40002c"    	#  WO: MAC address per port instead of shared MAC address
C_ADDR_NET_6T_ADDR_L="0x400030"    	#  WO: lower 32Bit of 6T Addr
C_ADDR_NET_6T_ADDR_H="0x400034"    	#  WO: upper Bits of 6T Addr
C_ADDR_NET_6T_SRC_PTR="0x400038"    	#  WO: Index in 6T Addr
C_ADDR_NET_6T_DST_PTR="0x40003c"    	#  WO: Index in 6T addr
C_ADDR_NET_TX_CONF_VLD="0x400040"    	#  RO: Currently active TX confirmation results  one bit per port
C_ADDR_NET_TX_CONF_L="0x400050"    	#  RO: Lower bound of the memorymapped TX confirmation result memory, consisting of one word Confirmation ID, followed by one word confirmation timestamp. Entry is cleared on reading the timestamp
C_ADDR_NET_TX_CONF_H="0x4000cc"    	#  RO: Upper bound
C_BASE_ADDR_RTC="0x7F00"	#  rtc_mmi
C_ADDR_RTC_BRIDGE_LOW="0x7f0000"    	#  RO: Lower 32 bits of current bridge clock value. Reading samples bridge and controlled clock
C_ADDR_RTC_BRIDGE_HIGH="0x7f0004"    	#  RO: Upper 32 bits of sampled bridge clock value
C_ADDR_RTC_CTRLD_LOW="0x7f0008"    	#  RO: Lower 32 bits of sampled controlled clock value
C_ADDR_RTC_CTRLD_HIGH="0x7f000c"    	#  RO: Upper 32 bits of sampled controlled clock value
C_ADDR_RTC_CTRLD_OFFSET_LOW="0x7f0010"    	#  WO: Lower 32 bits of controlled clock offset [ns]: at which offset should the clock have started at reset?
C_ADDR_RTC_CTRLD_OFFSET_HIGH="0x7f0014"    	#  WO: Upper 32 bits of controlled clock offset [ns]. Writing this activates the new lower and higher part
C_ADDR_RTC_CTRLD_RATE="0x7f0018"    	#  WO: Controlled clock rate (upper 8 bits are [ns], lower 24 bits are subns): how much to be added every 5 ns?
C_ADDR_RTC_INTERRUPT="0x7f001c"    	#  RO: Address for RTC interrupts, COR: at least one of the internal counters lapsed
C_ADDR_RTC_INTERRUPT_EN="0x7f0020"    	#  RW: Address for RTC interrupt mask
C_ADDR_RTC_CLKSEL="0x7f0024"    	#  WO: Clock selection for the TAS: 0=free running/bridge clock, 1=controlled clock
C_ADDR_RTC_SEC_START_L="0x7f0028"    	#  UNUSED
C_ADDR_RTC_SEC_START_H="0x7f002c"    	#  UNUSED
C_ADDR_RTC_SEC_START="0x7f002c"    	#  UNUSED
C_BASE_ADDR_PPS="0x7F01"	#  sample_event_mmi
C_ADDR_PPS_INTERRUPT="0x7f0100"    	#  RO: Address for PPS interrupt
C_ADDR_PPS_INTERRUPT_EN="0x7f0104"    	#  RW: Address for PPS interrupt mask
C_ADDR_PPS_CTRLD_LOW="0x7f0108"    	#  RO: Lower 32 bits of sampled controlled clock value
C_ADDR_PPS_CTRLD_HIGH="0x7f010c"    	#  RO: Upper 32 bits of sampled controlled clock value
C_ADDR_PPS_SAMPLE_VAL="0x7f0110"    	#  RO: Value of event input after the change
C_ADDR_HC_CNT_BAD_FRAMES="0x7f0100"    	#  RO, COR
C_ADDR_HC_INTERRUPT="0x7f0104"    	#  RO, COR
C_ADDR_HC_INTERRUPT_EN="0x7f0108"    	#  RW
C_ADDR_HC_DEFAULT_FLOWID="0x7f010c"    	#  WO @TODO No effect as long as flow_cache_lib.priority_encoder overrides this
C_ADDR_HC_DEFAULT_CUT_THROUGH="0x7f0110"    	#  WO
C_ADDR_HC_CNT_HT_DROP_FRAMES="0x7f0114"    	#  RO, COR
C_BASE_ADDR_USER_MOD="0x8800"	#  user_module_mmi
C_ADDR_USER_MOD_MMI_ID="0x880000"    	#  RO: Address for "unique" pattern
C_ADDR_USER_MOD_MMI_BEEP_EN="0x880004"    	#  WO: Address to enable beeping
C_ADDR_USER_MOD_MMI_DISPLAY_EN="0x880008"    	#  WO: Address to enable display dots
C_BASE_ADDR_NOC_ACTION_LOWER="0x8900"	#  WO: Action table  Has to be a multiple of 4, better a multiple of 0x100
C_BASE_ADDR_NOC_ACTION_UPPER="0x89FF"	#
C_BASE_ADDR_VLAN_STRIP_LOWER="0x8A00"	#  WO: Action table  Has to be a multiple of 4, better a multiple of 0x100
C_BASE_ADDR_VLAN_STRIP_UPPER="0x8AFF"	#
C_BASE_ADDR_FLOW_CACHE_HASH_LOWER="0x9000"	#  WO: EMH hash table
C_BASE_ADDR_FLOW_CACHE_HASH_UPPER="0x9FFF"	#
C_BASE_ADDR_FLOW_CACHE_FIELD_LOWER="0xB000"	#  WO: EMH rules table  Should be a multiple of 0x1000
C_BASE_ADDR_FLOW_CACHE_FIELD_UPPER="0xBFFF"	#
C_BASE_ADDR_FLOW_CACHE_LINEAR_LOWER="0xC000"	#  WO: EMH linear search  Has to be a multiple of 4, better a multiple of 0x100
C_BASE_ADDR_FLOW_CACHE_LINEAR_UPPER="0xC0FF"	#
C_BASE_ADDR_FLOW_CACHE_EMA_LOWER="0xC100"	#  WO: EMA rules table  Has to be a multiple of 4, better a multiple of 0x100
C_BASE_ADDR_FLOW_CACHE_EMA_UPPER="0xC1FF"	#
C_BASE_ADDR_FLOW_CACHE_EMA_CAM_LOWER="0xC200"	#  WO: EMA CAM  Has to be a multiple of 0x20
C_BASE_ADDR_FLOW_CACHE_EMA_CAM_UPPER="0xC21F"	#
C_BASE_ADDR_FLOW_CACHE="0xC300"	#  WO: General FlowCache configuration
C_ADDR_FLOW_CACHE_ENABLE="0xc30000"    	#  WO: Enable or disable parts of the FlowCache
C_ADDR_FLOW_CACHE_HASH_ID="0xc30004"    	#  RO: Identifier for the hashes used
C_ADDR_FLOW_CACHE_TCAM_ID="0xc30008"    	#  RO: Identifier for the TCAM input combination used
C_ADDR_FLOW_CACHE_RULE_SET="0xc3000c"    	#  RW: Hardware Variable for Hashing
C_ADDR_FLOW_CACHE_PTP_QUEUE="0xc30010"    	#  WO: PTP Queue selection via MMI
C_ADDR_FLOW_CACHE_FIELD_8BIT_OFFSET="0xc30014"    	#  WO: PTP Queue selection via MMI
C_ADDR_FLOW_CACHE_FIELD_16BIT_OFFSET="0xc30018"    	#  WO: PTP Queue selection via MMI
C_ADDR_FLOW_CACHE_FIELD_32BIT_OFFSET="0xc3001c"    	#  WO: PTP Queue selection via MMI
C_ADDR_FLOW_CACHE_VLAN_INT_LOWER="0xc30040"    	#  WO: Lower limit of internal VLANs > Port 0 (has to be a multiple of 0x40)
C_ADDR_FLOW_CACHE_VLAN_INT_UPPER="0xc3007c"    	#  WO: Upper limit of internal VLANs > Port 15 (has to be a multiple of 0x40  4)
C_BASE_ADDR_TM_LOWER="0xD000"	#  mmi_tm
C_BASE_ADDR_TM_UPPER="0xD011"	#  mmi_tm
C_ADDR_TM_RESOURCE_LIMIT_LOWER="0xd00000"    	#  WO: Resource limit per flow, measured in segment buffers (64 Bytes of frame data, without FCS)
C_ADDR_TM_RESOURCE_LIMIT_UPPER="0xd007ff"    	#  WO: Resource limit per flow, measured in segment buffers (64 Bytes of frame data, without FCS)
C_ADDR_TM_DROP_CNT_LOWER="0xd00800"    	#  RO, COR: TM Drop Counters  start
C_ADDR_TM_DROP_CNT_UPPER="0xd00fff"    	#  RO, COR: TM Drop Counters  end
C_ADDR_TM_REPLICATION_BITMAP_LOWER="0xd01000"    	#  WO: Frame replication bitmap per flow, overriding output port, if bitmap > 0
C_ADDR_TM_REPLICATION_BITMAP_UPPER="0xd010ff"    	#  WO: Frame replication bitmap per flow, overriding output port, if bitmap > 0
C_ADDR_TM_QUEUE_THRES_FULL="0xd01100"    	#  WO: Queue thresholds
C_ADDR_TM_RX_BUF_AVAIL="0xd01104"    	#  RO: Buffer available per RXDP/TXDP combination
C_ADDR_TM_PTR_CNT="0xd01108"    	#  RO: no. of pointers in use in the buffer.  UNUSED
C_ADDR_TM_EN_MAX_TRANSIT_DELAY="0xd0110c"    	#  WO: Enable/Disable Drop Jobs (1 second transit delay)
C_ADDR_TM_QM_DROP_RSN="0xd01110"    	#  RO, COR: Drop reasons since last read
C_ADDR_TM_QM_TX_REJ="0xd01114"    	#  RO, COR: TX rejection reasons since last read
C_ADDR_TM_DBG="0xd01118"    	#  RO, COR: Debug signals from TM units
C_BASE_ADDR_TM_SCHED_LOWER="0xD200"	#  scheduler_tas
C_BASE_ADDR_TM_SCHED_UPPER="0xDFFF"	#  scheduler_tas
C_ADDR_C_BLOCK_SIZE_ADDR_TM_SCHED="0xd20800"    	#  The size of the TM_SCHED address space assigned as a block to each port @todo rename to C_SUB_ADDR_TM_SCHED_BLOCK_SIZE_ADDR  UNUSED
C_ADDR_TM_SCHED_TAS_CONFIG_REG_LOWER="0xd20400"    	#  see below
C_ADDR_TM_SCHED_PROC_QUEUE_PRIO_LOWER="0xd20500"    	# UNUSED
C_ADDR_TM_SCHED_PROC_QUEUE_PRIO_UPPER="0xd2053c"    	# UNUSED
C_ADDR_TM_SCHED_PROC_QUEUE_PRIO_HIGH="0xd20540"    	# UNUSED   if '1' proc queues have higher priority than physical queues for this port
C_ADDR_TM_SCHED_TAS_CUR_TIME="0xd20544"    	#  readonly/debugonly: current time seen by the TAS, to be replaced by a clock (PTP or other)  UNUSED
C_ADDR_TM_SCHED_TAS_ADMIN_BASE_TIME="0xd20404"    	#  C_TSN_TIME_WIDTH
C_ADDR_TM_SCHED_TAS_ADMIN_CYCLE_TIME="0xd20408"    	#  C_TSN_TIME_WIDTH
C_ADDR_TM_SCHED_TAS_ADMIN_CYCLE_TIME_EXT="0xd2040c"    	#  C_TSN_TIME_WIDTH
C_ADDR_TM_SCHED_TAS_ADMIN_GATE_STATES="0xd20438"    	#  8 bit default gate state
C_ADDR_TM_SCHED_TAS_ADMIN_GCL_LEN="0xd20400"    	#  7 bit reg
C_ADDR_TM_SCHED_TAS_CONFIG_CHANGE="0xd2041c"    	#  one bit indicator, enable config change
C_ADDR_TM_SCHED_TAS_CONFIG_CHANGE_PENDING="0xd20420"    	#  RO: one bit indicator, pending config change
C_ADDR_TM_SCHED_TAS_CONFIG_CHANGE_TIME="0xd20410"    	#  C_TAS_TIME_WIDTH
C_ADDR_TM_SCHED_TAS_GATE_ENABLE="0xd20418"    	#  one bit indicator, enable/disable TAS for port
C_ADDR_TM_SCHED_TAS_OPER_BASE_TIME="0xd2042c"    	#  C_TAS_TIME_WIDTH read only
C_ADDR_TM_SCHED_TAS_OPER_CYCLE_TIME="0xd20430"    	#  C_TAS_TIME_WIDTH read only
C_ADDR_TM_SCHED_TAS_OPER_CYCLE_TIME_EXT="0xd20434"    	#  C_TAS_TIME_WIDTH read only
C_ADDR_TM_SCHED_TAS_OPER_GATE_STATES="0xd2043c"    	#  8 bit default gate state
C_ADDR_TM_SCHED_TAS_OPER_GCL_LEN="0xd20428"    	#  7 bit reg read only
C_ADDR_TM_SCHED_TAS_CYCLE_START_TIME="0xd20414"    	#  C_TAS_TIME_WIDTH
C_ADDR_TM_SCHED_TAS_CONFIG_CHANGE_ACK="0xd20424"    	#  read only ack
C_ADDR_SCHED_TAS_ADMIN_BASE_TIME="0xd20404"    	#  R/W     8.6.9.4.1  Software has to set a value at least AdminCycleTime in the future + ~1 ms and less than 2 seconds in the future
C_ADDR_SCHED_TAS_ADMIN_CYCLE_TIME="0xd20408"    	#  R/W     8.6.9.4.3  Software has to break down the rational number to a value in [ns]
C_ADDR_SCHED_TAS_ADMIN_CYCLE_TIME_EXTENSION="0xd2040c"    	#  R/W     8.6.9.4.4  Software has to make sure that AdminCycleTime+AdminCycleTimeExtension never produces a _31_ bit integer overflow
C_ADDR_SCHED_TAS_ADMIN_GATE_STATES="0xd20438"    	#  R/W     8.6.9.4.5
C_ADDR_SCHED_TAS_ADMIN_CONTROL_LIST_LENGTH="0xd20400"    	#  R/W     8.6.9.4.6  only lower bits are considered by hardware  software has to make sure that no bigger number is configured
C_ADDR_SCHED_TAS_CONFIG_CHANGE="0xd2041c"    	#  R/W     8.6.9.4.7
C_ADDR_SCHED_TAS_CONFIG_PENDING="0xd20420"    	#  RO      8.6.9.4.8
C_ADDR_SCHED_TAS_CONFIG_CHANGE_TIME="0xd20410"    	#  RO      8.6.9.4.9
C_ADDR_SCHED_TAS_CONFIG_CHANGE_ERROR="0xd20440"    	#  RO, COR Without number  Software has to aggregate to 64 bits
C_ADDR_SCHED_TAS_GATE_ENABLED="0xd20418"    	#  R/W     8.6.9.4.14
C_ADDR_SCHED_TAS_OPER_BASE_TIME="0xd2042c"    	#  RO      8.6.9.4.18
C_ADDR_SCHED_TAS_OPER_CYCLE_TIME="0xd20430"    	#  RO      8.6.9.4.20  Software has to convert the [ns] value back to a rational number
C_ADDR_SCHED_TAS_OPER_CYCLE_TIME_EXTENSION="0xd20434"    	#  RO      8.6.9.4.21
C_ADDR_SCHED_TAS_OPER_GATE_STATES="0xd2043c"    	#  RO      8.6.9.4.22
C_ADDR_SCHED_TAS_OPER_CONTROL_LIST_LENGTH="0xd20428"    	#  RO      8.6.9.4.23
C_ADDR_SCHED_TAS_GCL_MEM_GATES="0xd20000"    	#  R/W     8.6.9.4.2
C_ADDR_SCHED_TAS_GCL_MEM_TIMES="0xd20200"    	#  R/W     8.6.9.4.2  Software has to make sure that no TimeInverval is > 2 seconds (better < 1 second)
C_ADDR_TM_SCHED_TAS_TICK_GRANULARITY="0xd20444"    	#  TAS Tick Granularity
C_ADDR_TM_SCHED_TAS_TRIGGER_EN="0xd20450"    	#  WO Amount of Triggerperiods
C_ADDR_TM_SCHED_TAS_TRIGGER_CNT="0xd20454"    	#  WO Amount of Triggerperiods
C_BASE_ADDR_TX_ROUTER_LOWER_0="0xE100"	#
C_BASE_ADDR_TX_ROUTER_LOWER_1="0xE200"	#
C_BASE_ADDR_TX_ROUTER_UPPER_0="0xE10F"	#
C_BASE_ADDR_TX_ROUTER_UPPER_1="0xE20F"	#
FEATURE_0_NAME="Triggergenerator"
FEATURE_0_DESCRIPTION="PTP synchronized signalgenerator with adjustable DUTY_CYCLE, PERIOD and Start Time as a PHASESHIFT with nanosecond accuracy at PMOD pin 4."
